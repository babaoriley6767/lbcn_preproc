function EpochDataAll_par(sbj_name, project_name, bn, dirs,elecs,locktype,bef_time,aft_time,datatype,thr_raw,thr_diff,blc)

%% INPUTS:
%   sbj_name: subject name
%   project_name: name of task
%   block_names: blocks to be analyed (cell of strings)
%   dirs: directories pointing to files of interest (generated by InitializeDirs)
%   elecs: can select subset of electrodes to epoch (default: all)
%   locktype: 'stim' or 'resp' (which events to timelock to)
%   bef_time: time (in s) before event to start each epoch of data
%   aft_time: time (in s) after event to end each epoch of data
%   datatype: 'CAR', 'HFB', or 'Spect' (which type of data to load and epoch)
%   thr_raw: threshold for raw data (z-score threshold relative to all data points) to exclude timepoints
%   thr_diff: threshold for changes in signal (diff bw two consecutive points; also z-score)
%   blc: baseline correction
%       .run: true or false (whether to run baseline correction)
%       .locktype: 'stim' or 'resp' (which event to use to choose baseline window)
%       .win: 2-element vector specifiying window relative to lock event to use for baseline, in sec (e.g. [-0.2 0])

% set default paramters (if inputs are missing or empty)

if nargin < 12 || isempty(blc)
    blc.run = true;
    blc.locktype = 'stim';
    blc.win = [-0.2 0];
end
if nargin < 11 || isempty(thr_diff)
    thr_diff = 15;
end
if nargin < 10 || isempty(thr_raw)
    thr_raw = 15;
end
if nargin < 9 || isempty(datatype)
    datatype = 'CAR';
end
if nargin < 8 || isempty(aft_time)
    aft_time = 3;
end
if nargin < 7 || isempty(bef_time)
    bef_time = -0.5;
end
if nargin < 6 || isempty(locktype)
    locktype = 'stim';
end

% Check if baseline window is within desired epoched window
% Otherwise, will need to epoch baseline separately and add as separate
% input to baseline correction function
if blc.run && ~(strcmp(locktype,blc.locktype) && blc.win(1)>=bef_time && blc.win(2) <= aft_time)
    sep_bl = true;
else
    sep_bl = false;
end

%% loop through electrodes

% Load globalVar
fn = sprintf('%s/originalData/%s/global_%s_%s_%s.mat',dirs.data_root,sbj_name,project_name,sbj_name,bn);
load(fn,'globalVar');

% dir_CAR = [dirs.data_root,'/originalData/',sbj_name,'/',bn];
dir_in = [dirs.data_root,'/',datatype,'Data/',sbj_name,'/',bn];
dir_out = [dirs.data_root,'/',datatype,'Data/',sbj_name,'/',bn, '/EpochData'];


if nargin < 5 || isempty(elecs)
    elecs = setdiff(1:globalVar.nchan,globalVar.refChan);
end

% load trialinfo
load([dirs.result_root,'/',project_name,'/',sbj_name,'/',bn,'/trialinfo_',bn,'.mat'])
% Select only trials that are not rest
trialinfo = trialinfo(~strcmp(trialinfo.condNames, 'rest'),:);


if strcmp(locktype,'stim')
    lockevent = trialinfo.allonsets(:,1);
elseif strcmp(locktype,'resp')
    lockevent = trialinfo.RT_lock;
else
    lockevent = [];
end

if sep_bl
    if strcmp(blc.locktype,'stim')
        bl_lockevent = trialinfo.allonsets(:,1);
    elseif strcmp(bl.locktype,'resp')
        bl_lockevent = trialinfo.RT_lock;
    else
        bl_lockevent = [];
    end
end

%% Get HFO bad trials:
pTS = globalVar.pathological_event_bipolar_montage;
[bad_epochs_HFO, bad_indices_HFO] = exclude_trial(pTS.ts,pTS.channel, lockevent, globalVar.channame, bef_time, aft_time, globalVar.iEEG_rate);
% Put the indices to the final sampling rate
bad_indices_HFO = cellfun(@(x) round(x./(globalVar.iEEG_rate)), bad_indices_HFO, 'UniformOutput',false); %%% CHECK THAT
% bad_indices_HFO = cellfun(@(x) round(x./(globalVar.iEEG_rate/globalVar.fs_comp)), bad_indices_HFO, 'UniformOutput',false);


parfor ei = 1:length(elecs)
    EpochDataAll_par_elect(elecs, ei, dir_in, datatype,lockevent, locktype, bn, globalVar, bef_time,aft_time, sep_bl, trialinfo, thr_raw, thr_diff, bad_epochs_HFO, bad_indices_HFO, blc, dir_out)
end

%% save updated globalVar (with bad epochs)
fn = [dirs.data_root,'/OriginalData/',sbj_name,'/global_',project_name,'_',sbj_name,'_',bn,'.mat'];
save(fn,'globalVar')

end


